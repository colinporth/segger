// main.cpp - msc class usb
//{{{  includes
#include "../common/system.h"
#include "cLcd.h"
#include "../common/cTouch.h"
#include "../common/cPs2.h"

#include "usbd_msc.h"
#include "../FatFs/ff.h"

#include "cLcd.h"
#include "stm32746g_discovery_sd.h"
#include "cCamera.h"

#include "jpeglib.h"

#include "cmsis_os.h"
#include "lwip/opt.h"
#include "lwip/netif.h"
#include "lwip/tcpip.h"
#include "lwip/dhcp.h"
#include "lwip/arch.h"
#include "lwip/apps/fs.h"
#include "lwip/api.h"

#include "ethernetif.h"
//}}}
#define USE_CAMERA

const char* kVersion = "WebCam 14/4/18";
const char* kEmpty = "empty";

uint16_t* kRgb565Buffer = (uint16_t*)0xc0100000;
uint8_t*  kJpegBuffer   =  (uint8_t*)0xc0200000;

cCamera camera;

//{{{
class cApp : public cTouch {
public:
  cApp (int x, int y) : cTouch (x,y) {
    mBufferArray[0] = (uint8_t*)malloc (1600 * 3);
    mCinfo.err = jpeg_std_error (&jerr);
    jpeg_create_decompress (&mCinfo);
    }
  ~cApp() {
    jpeg_destroy_decompress (&mCinfo);
    }

  cLcd* getLcd() { return mLcd; }
  cPs2* getPs2() { return mPs2; }

  void init();
  void run();
  void onPs2Irq() { mPs2->onIrq(); }

  //{{{
  int getCountFiles (char* path) {
    mFiles = 0;
    countFiles (path);
    return mFiles;
    }
  //}}}

protected:
  virtual void onProx (int x, int y, int z);
  virtual void onPress (int x, int y);
  virtual void onMove (int x, int y, int z);
  virtual void onScroll (int x, int y, int z);
  virtual void onRelease (int x, int y);
  virtual void onKey (uint8_t ch, bool release);

private:
  void readDirectory (char* path);
  void countFiles (char* path);
  void reportFree();
  void reportLabel();

  int loadFile (uint8_t* jpegBuffer);
  void saveFile (uint8_t* jpegHeadBuf, int jpegHeadLen, uint8_t* jpegBuf, int jpegLen, int num);
  void jpegDecode (uint8_t* jpegBuf, int jpegLen, uint16_t* rgb565buf, int scale);

  int jfifApp0Marker (uint8_t* ptr);
  int sofMarker (uint8_t* ptr, int width, int height);
  int quantTableMarker (uint8_t* ptr, int qscale);
  int huffTableMarkerDC (uint8_t* ptr, const uint16_t* htable, int classId);
  int huffTableMarkerAC (uint8_t* ptr, const uint16_t* htable, int classId);
  int sosMarker (uint8_t* ptr);
  void setJpegHeader (int width, int height, int qscale);

  cLcd* mLcd = nullptr;
  cCamera* mCamera = nullptr;
  cPs2* mPs2 = nullptr;

  int mFiles = 0;
  DWORD mVsn = 0;
  char mLabel[40];
  uint8_t* mBufferArray[1];

  struct jpeg_error_mgr jerr;
  struct jpeg_decompress_struct mCinfo;
  uint8_t mJpegHeader[1000];
  int mJpegHeaderLen = 0;
  };
//}}}
cApp* gApp;
extern "C" { void EXTI9_5_IRQHandler() { gApp->onPs2Irq(); } }

struct netif gnetif;
//{{{
void dhcpThread (void* argument) {

  #define DHCP_OFF                   (uint8_t) 0
  #define DHCP_START                 (uint8_t) 1
  #define DHCP_WAIT_ADDRESS          (uint8_t) 2
  #define DHCP_ADDRESS_ASSIGNED      (uint8_t) 3
  #define DHCP_TIMEOUT               (uint8_t) 4
  #define DHCP_LINK_DOWN             (uint8_t) 5
  #define MAX_DHCP_TRIES  4

  auto netif = (struct netif*)argument;
__IO uint8_t DHCP_state = netif_is_up (netif) ? DHCP_START : DHCP_LINK_DOWN;

  gApp->getLcd()->debug (LCD_COLOR_YELLOW, "DHCP - launched");

  for (;;) {
    switch (DHCP_state) {
      case DHCP_START:
        ip_addr_set_zero_ip4 (&netif->ip_addr);
        ip_addr_set_zero_ip4 (&netif->netmask);
        ip_addr_set_zero_ip4 (&netif->gw);
        dhcp_start (netif);
        DHCP_state = DHCP_WAIT_ADDRESS;
        gApp->getLcd()->debug (LCD_COLOR_WHITE, "DHCP - looking for server");
        break;

      case DHCP_WAIT_ADDRESS:
        if (dhcp_supplied_address (netif)) {
          DHCP_state = DHCP_ADDRESS_ASSIGNED;
          gApp->getLcd()->debug (LCD_COLOR_WHITE, "DHCP - address assigned");
          gApp->getLcd()->debug (LCD_COLOR_GREEN, ip4addr_ntoa ((const ip4_addr_t*)&netif->ip_addr));
          }
        else {
          auto dhcp = (struct dhcp*)netif_get_client_data (netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP);
          if (dhcp->tries > MAX_DHCP_TRIES) {
            DHCP_state = DHCP_TIMEOUT;
            dhcp_stop (netif);
            gApp->getLcd()->debug (LCD_COLOR_RED, "DHCP - timeout");
            }
          }
        break;

      case DHCP_LINK_DOWN:
        gApp->getLcd()->debug (LCD_COLOR_RED, "DHCP - link down");
        dhcp_stop (netif);
        DHCP_state = DHCP_OFF;
        break;

      default:
        break;
      }

    osDelay (250);
    }
  }
//}}}

int numPageHits = 0;
//{{{
const unsigned char kDynamicPage[] = {
0x3c,0x21,0x44,0x4f,0x43,0x54,0x59,0x50,0x45,0x20,0x68,0x74,0x6d,0x6c,0x20,0x50,
0x55,0x42,0x4c,0x49,0x43,0x20,0x22,0x2d,0x2f,0x2f,0x57,0x33,0x43,0x2f,0x2f,0x44,
0x54,0x44,0x20,0x48,0x54,0x4d,0x4c,0x20,0x34,0x2e,0x30,0x31,0x2f,0x2f,0x45,0x4e,
0x22,0x20,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x77,0x33,
0x2e,0x6f,0x72,0x67,0x2f,0x54,0x52,0x2f,0x68,0x74,0x6d,0x6c,0x34,0x2f,0x73,0x74,
0x72,0x69,0x63,0x74,0x2e,0x64,0x74,0x64,0x22,0x3e,0x0d,0x0a,0x3c,0x68,0x74,0x6d,
0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x74,
0x69,0x74,0x6c,0x65,0x3e,0x53,0x54,0x4d,0x33,0x32,0x46,0x37,0x78,0x78,0x54,0x41,
0x53,0x4b,0x53,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,0x71,0x75,0x69,0x76,0x3d,
0x22,0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x22,0x0d,0x0a,
0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x74,0x65,0x78,0x74,0x2f,0x68,
0x74,0x6d,0x6c,0x3b,0x20,0x63,0x68,0x61,0x72,0x73,0x65,0x74,0x3d,0x77,0x69,0x6e,
0x64,0x6f,0x77,0x73,0x2d,0x31,0x32,0x35,0x32,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,0x71,0x75,0x69,0x76,0x3d,
0x22,0x72,0x65,0x66,0x72,0x65,0x73,0x68,0x22,0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,
0x74,0x3d,0x22,0x31,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x6d,0x65,0x74,0x61,0x20,
0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x4d,0x53,0x48,0x54,0x4d,0x4c,0x20,
0x36,0x2e,0x30,0x30,0x2e,0x32,0x38,0x30,0x30,0x2e,0x31,0x35,0x36,0x31,0x22,0x20,
0x6e,0x61,0x6d,0x65,0x3d,0x22,0x47,0x45,0x4e,0x45,0x52,0x41,0x54,0x4f,0x52,0x22,
0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x73,0x74,0x79,0x6c,0x65,0x20,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x6e,0x6f,0x72,0x6d,0x61,
0x6c,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,
0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x22,0x3e,0x3c,0x2f,0x73,0x74,0x79,0x6c,
0x65,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,
0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x68,0x34,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x20,
0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,
0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x22,0x3e,0x3c,0x73,
0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,
0x62,0x69,0x67,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,
0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,
0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,0x73,0x74,0x72,0x6f,0x6e,0x67,0x3e,0x3c,0x65,
0x6d,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,
0x22,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,
0x6c,0x69,0x63,0x3b,0x22,0x3e,0x53,0x54,0x4d,0x33,0x32,0x46,0x37,0x78,0x78,0x20,
0x4c,0x69,0x73,0x74,0x20,0x6f,0x66,0x20,0x74,0x61,0x73,0x6b,0x73,0x20,0x61,0x6e,
0x64,0x0d,0x0a,0x74,0x68,0x65,0x69,0x72,0x20,0x73,0x74,0x61,0x74,0x75,0x73,0x3c,
0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x2f,0x65,0x6d,0x3e,0x3c,0x2f,0x73,0x74,0x72,
0x6f,0x6e,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,
0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x73,0x6d,
0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x68,0x34,
0x3e,0x0d,0x0a,0x3c,0x68,0x72,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x77,0x69,
0x64,0x74,0x68,0x3a,0x20,0x31,0x30,0x30,0x25,0x3b,0x20,0x68,0x65,0x69,0x67,0x68,
0x74,0x3a,0x20,0x32,0x70,0x78,0x3b,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,
0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,
0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x0d,0x0a,0x3c,0x2f,
0x73,0x70,0x61,0x6e,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,
0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,
0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x0d,0x0a,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x77,0x69,0x64,0x74,0x68,0x3a,0x20,0x39,0x36,0x31,
0x70,0x78,0x3b,0x20,0x68,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x33,0x30,0x70,0x78,
0x3b,0x22,0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x31,0x22,0x0d,0x0a,0x20,
0x63,0x65,0x6c,0x6c,0x70,0x61,0x64,0x64,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x20,
0x63,0x65,0x6c,0x6c,0x73,0x70,0x61,0x63,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x3e,
0x0d,0x0a,0x20,0x20,0x3c,0x74,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x20,0x20,0x20,
0x20,0x3c,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x64,
0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,
0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x20,
0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,
0x64,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,
0x74,0x61,0x6c,0x69,0x63,0x3b,0x20,0x62,0x61,0x63,0x6b,0x67,0x72,0x6f,0x75,0x6e,
0x64,0x2d,0x63,0x6f,0x6c,0x6f,0x72,0x3a,0x20,0x72,0x67,0x62,0x28,0x35,0x31,0x2c,
0x20,0x35,0x31,0x2c,0x20,0x32,0x35,0x35,0x29,0x3b,0x20,0x74,0x65,0x78,0x74,0x2d,
0x61,0x6c,0x69,0x67,0x6e,0x3a,0x20,0x63,0x65,0x6e,0x74,0x65,0x72,0x3b,0x22,0x3e,
0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x61,0x0d,0x0a,0x20,0x68,0x72,0x65,0x66,
0x3d,0x22,0x2f,0x53,0x54,0x4d,0x33,0x32,0x46,0x37,0x78,0x78,0x2e,0x68,0x74,0x6d,
0x6c,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,
0x63,0x6f,0x6c,0x6f,0x72,0x3a,0x20,0x77,0x68,0x69,0x74,0x65,0x3b,0x22,0x3e,0x48,
0x6f,0x6d,0x65,0x0d,0x0a,0x70,0x61,0x67,0x65,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
0x3c,0x2f,0x61,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x74,0x64,
0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x64,0x0d,0x0a,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,
0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x20,0x66,0x6f,0x6e,0x74,
0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x20,0x66,
0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,0x6c,0x69,
0x63,0x3b,0x20,0x62,0x61,0x63,0x6b,0x67,0x72,0x6f,0x75,0x6e,0x64,0x2d,0x63,0x6f,
0x6c,0x6f,0x72,0x3a,0x20,0x72,0x67,0x62,0x28,0x35,0x31,0x2c,0x20,0x35,0x31,0x2c,
0x20,0x32,0x35,0x35,0x29,0x3b,0x20,0x74,0x65,0x78,0x74,0x2d,0x61,0x6c,0x69,0x67,
0x6e,0x3a,0x20,0x63,0x65,0x6e,0x74,0x65,0x72,0x3b,0x22,0x3e,0x3c,0x61,0x0d,0x0a,
0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x53,0x54,0x4d,0x33,0x32,0x46,0x37,0x78,0x78,
0x41,0x44,0x43,0x2e,0x68,0x74,0x6d,0x6c,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,
0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,
0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x3c,0x2f,0x73,0x70,0x61,
0x6e,0x3e,0x3c,0x2f,0x61,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x61,0x0d,
0x0a,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x2f,0x53,0x54,0x4d,0x33,0x32,0x46,0x37,
0x78,0x78,0x54,0x41,0x53,0x4b,0x53,0x2e,0x68,0x74,0x6d,0x6c,0x22,0x3e,0x3c,0x73,
0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x63,0x6f,0x6c,0x6f,0x72,
0x3a,0x20,0x77,0x68,0x69,0x74,0x65,0x3b,0x22,0x3e,0x4c,0x69,0x73,0x74,0x0d,0x0a,
0x6f,0x66,0x20,0x74,0x61,0x73,0x6b,0x73,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,
0x2f,0x61,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x74,0x64,0x3e,
0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x2f,0x74,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,
0x3e,0x0d,0x0a,0x3c,0x62,0x72,0x3e,0x0d,0x0a,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,
0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,
0x3e,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,
0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,
0x6e,0x61,0x3b,0x22,0x3e,0x4e,0x75,0x6d,0x62,0x65,0x72,0x20,0x6f,0x66,0x20,0x70,
0x61,0x67,0x65,0x20,0x68,0x69,0x74,0x73,0x3a,0x0d,0x0a,0x00};
//}}}
//{{{
void httpServerThread (void *arg) {

  // Create a new TCP connection handle
  struct netconn* connection = netconn_new (NETCONN_TCP);
  if (connection != NULL) {
    // Bind to port 80 (HTTP) with default IP address
    if (netconn_bind (connection, NULL, 80) == ERR_OK) {
      netconn_listen (connection);
      while (true) {
        struct netconn* request;
        if (netconn_accept (connection, &request) == ERR_OK) {
          struct netbuf* requestNetBuf;
          if (netconn_recv (request, &requestNetBuf) == ERR_OK) {
            if (netconn_err (request) == ERR_OK) {
              char* buf;
              u16_t buflen;
              netbuf_data (requestNetBuf, (void**)&buf, &buflen);

              // simple HTTP GET command parser
              if ((buflen >= 5) && (strncmp (buf, "GET /", 5) == 0)) {
                struct fs_file file;
                if (strncmp(buf, "GET /STM32F7xxTASKS.html", 24) == 0) {
                  netconn_write (request, kDynamicPage, strlen ((char*)kDynamicPage), NETCONN_COPY);
                  char body[512];
                  sprintf (body, "%d", numPageHits++);
                  strcat (body, "<pre><br>Name          State  Priority  Stack   Num<br>");
                  osThreadList ((unsigned char*)(body + strlen (body)));
                  netconn_write (request, body, strlen (body), NETCONN_COPY);
                  }
                else if ((strncmp (buf, "GET /STM32F7xx.html", 19) == 0) || (strncmp (buf, "GET / ", 6) == 0)) {
                  fs_open (&file, "/STM32F7xx.html");
                  netconn_write (request, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                  fs_close (&file);
                  }
                else if (strncmp ((char const*)buf,"GET /STM32F7xx_files/ST.gif", 27)==0) {
                  fs_open (&file, "/STM32F7xx_files/ST.gif");
                  netconn_write (request, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                  fs_close (&file);
                  }
                else if (strncmp( (char const*)buf,"GET /STM32F7xx_files/stm32.jpg", 30)==0) {
                  fs_open (&file, "/STM32F7xx_files/stm32.jpg");
                  netconn_write (request, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                  fs_close (&file);
                  }
                else if (strncmp ((char const*)buf,"GET /STM32F7xx_files/logo.jpg", 29) == 0) {
                  fs_open (&file, "/STM32F7xx_files/logo.jpg");
                  netconn_write (request, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                  fs_close (&file);
                  }
                else {
                  fs_open (&file, "/404.html");
                  netconn_write (request, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                  fs_close (&file);
                  }
                }
              }
            }

          netconn_close (request);
          netbuf_delete (requestNetBuf);
          netconn_delete (request);
          }
        }
      }
    }
  }
//}}}

// public
//{{{
void cApp::init() {

  mLcd = new cLcd (16);
  mLcd->init();

  mLcd->start();
  mLcd->drawTitle (kVersion);
  mLcd->drawDebug();
  mLcd->present();

  //{{{  removed
  //mPs2 = new cPs2 (mLcd);
  //mPs2->initKeyboard();
  //}}}
  //mscInit (mLcd);
  //mscStart();
  }
//}}}
//{{{
void cApp::run() {

  uint8_t* jpegBuf = kJpegBuffer;
  //int jpegLen = loadFile (kJpegBuffer);
  int jpegLen = 0;

  //{{{
  #ifdef USE_CAMERA
    mCamera = new cCamera();
    mCamera->init();
    mCamera->start (true, kJpegBuffer);

    setJpegHeader (mCamera->getWidth(), mCamera->getHeight(), 6);
    mCinfo.scale_num = 1;
    mCinfo.scale_denom = (mCamera->getWidth() / mLcd->getWidth()) + 1;
    mCinfo.dct_method = JDCT_FLOAT;
    mCinfo.out_color_space = JCS_RGB;
  #endif
  //}}}

  int count = 0;
  int lastCount = 0;
  bool lastButton = false;
  while (true) {
    osDelay (20);
    pollTouch();
    //{{{  removed
    //while (mPs2->hasChar()) {
    //  auto ch = mPs2->getChar();
    //  onKey (ch & 0xFF, ch & 0x100);
    //  }
    //mLcd->startBgnd (kVersion, mscGetSectors());
    //}}}
    #ifdef USE_CAMERA
      if (mCamera->getCaptureMode()) {
        jpegBuf = mCamera->getJpegFrame (jpegLen);
        if (jpegBuf) {
          //{{{  jpeg decode buffer
          if (jpegBuf + jpegLen > (uint8_t*)0xc0600000)
            memcpy ((void*)0xc0600000, kJpegBuffer, jpegBuf + jpegLen - (uint8_t*)0xc0600000);

          // decode jpeg header
          jpeg_mem_src (&mCinfo, mJpegHeader, mJpegHeaderLen);
          jpeg_read_header (&mCinfo, TRUE);

          // decode jpeg body
          jpeg_mem_src (&mCinfo, jpegBuf, jpegLen);
          jpeg_start_decompress (&mCinfo);

          while (mCinfo.output_scanline < mCinfo.output_height) {
            jpeg_read_scanlines (&mCinfo, mBufferArray, 1);
            mLcd->convertRgb888toRgbB565 (mBufferArray[0], kRgb565Buffer + mCinfo.output_scanline * mCinfo.output_width, mCinfo.output_width);
            }
          jpeg_finish_decompress (&mCinfo);

          count++;
          //saveFile (mJpegHeader, mJpegHeaderLen, jpegBuf, jpegLen, count);
          }
          //}}}
        }
      mLcd->startBgnd (kRgb565Buffer, mCinfo.output_width, mCinfo.output_height, BSP_PB_GetState (BUTTON_KEY));
    #else
      //if (count < 3)
      //  saveFile (nullptr, 0, jpegBuf, jpegLen, count++);
      mLcd->startBgnd (kRgb565Buffer);
    #endif

    mLcd->drawTitle (kVersion);
    if (mCamera) {
      //{{{  drawInfo
      char info[40] = {0};
      sprintf (info, "%4d %2dfps %d", mCamera->getFrames(), mCamera->getFps(), mCamera->getJpegLen());
      mLcd->drawInfo (24, info);
      }
      //}}}
    mLcd->drawDebug();
    mLcd->present();

    bool button = BSP_PB_GetState (BUTTON_KEY);
    if (!button && (button != lastButton)) {
      if (mCamera) {
        auto captureMode = !mCamera->getCaptureMode();
        mCamera->start (captureMode, captureMode ? kJpegBuffer : (uint8_t*)kRgb565Buffer);
        }
      }
    lastButton = button;
    }
  }
//}}}

// protected
//{{{
void cApp::onProx (int x, int y, int z) {

  if (x || y) {
    //uint8_t HID_Buffer[HID_IN_ENDPOINT_SIZE] = { 0,(uint8_t)x,(uint8_t)y,0 };
    // hidSendReport (&gUsbDevice, HID_Buffer);
    mLcd->debug (LCD_COLOR_MAGENTA, "onProx %d %d %d", x, y, z);
    }
  }
//}}}
//{{{
void cApp::onPress (int x, int y) {

  //uint8_t HID_Buffer[HID_IN_ENDPOINT_SIZE] = { 1,0,0,0 };
  //hidSendReport (&gUsbDevice, HID_Buffer);
  mLcd->debug (LCD_COLOR_GREEN, "onPress %d %d", x, y);
  }
//}}}
//{{{
void cApp::onMove (int x, int y, int z) {

  if (x || y) {
    //uint8_t HID_Buffer[HID_IN_ENDPOINT_SIZE] = { 1,(uint8_t)x,(uint8_t)y,0 };
    //hidSendReport (&gUsbDevice, HID_Buffer);
    int focus = camera.getFocus() + x;
    if (focus < 0)
      focus = 0;
    else if (focus > 254)
      focus = 254;
    camera.setFocus (focus);
    mLcd->debug (LCD_COLOR_GREEN, "onMove %d %d %d %d", x, y, z, focus);
    }
  }
//}}}
//{{{
void cApp::onScroll (int x, int y, int z) {
  mLcd->incScrollValue (y);
  }
//}}}
//{{{
void cApp::onRelease (int x, int y) {

  //uint8_t HID_Buffer[HID_IN_ENDPOINT_SIZE] = { 0,0,0,0 };
  //hidSendReport (&gUsbDevice, HID_Buffer);
  mLcd->debug (LCD_COLOR_GREEN, "onRelease %d %d", x, y);
  }
//}}}
//{{{
void cApp::onKey (uint8_t ch, bool release) {

  //mLcd->debug (LCD_COLOR_GREEN, "onKey %x %s", ch, release ? "release" : "press");
  if (ch == 0x51) // down arrow
    mLcd->incScrollIndex (-1);
  else if (ch == 0x52) // up arrow
    mLcd->incScrollIndex (1);
  else if (ch == 0x4e) // pagedown
    mLcd->incScrollIndex (-16);
  else if (ch == 0x4b) // pageup
    mLcd->incScrollIndex (16);
  }
//}}}

// private
//{{{
void cApp::readDirectory (char* path) {

  DIR dir;
  auto result = f_opendir (&dir, path);
  if (result == FR_OK) {
    int i;
    for (i = 0; path[i]; i++);
    path[i++] = '/';

    while (true) {
      FILINFO fno;
      auto result = f_readdir (&dir, &fno);
      if (result != FR_OK || !fno.fname[0])
        break;
      if (fno.fname[0] == '.')
        continue;

      int j = 0;
      do {
        path[i+j] = fno.fname[j];
        } while (fno.fname[j++]);

      if (fno.fattrib & AM_DIR) {
        mLcd->debug (LCD_COLOR_GREEN, "%s", path);
        readDirectory (path);
        }
      else
        mLcd->debug (LCD_COLOR_WHITE, "%s", path);
      }

    path[--i] = '\0';
    f_closedir (&dir);
    }
  }
//}}}
//{{{
void cApp::countFiles (char* path) {

  DIR dir;
  auto result = f_opendir (&dir, path);
  if (result == FR_OK) {
    int i;
    for (i = 0; path[i]; i++);
    path[i++] = '/';

    while (true) {
      FILINFO fno;
      auto result = f_readdir (&dir, &fno);
      if (result != FR_OK || !fno.fname[0])
        break;
      if (fno.fname[0] == '.')
        continue;

      int j = 0;
      do {
        path[i+j] = fno.fname[j];
        } while (fno.fname[j++]);

      if (fno.fattrib & AM_DIR)
        countFiles (path);
      else
        mFiles++;
      }

    path[--i] = '\0';
    f_closedir (&dir);
    }
  }
//}}}
//{{{
void cApp::reportFree() {

  DWORD freeClusters;
  FATFS* fatFs;
  if (f_getfree ("0:", &freeClusters, &fatFs) != FR_OK)
    mLcd->debug (LCD_COLOR_WHITE, "f_getfree failed");
  else {
    int freeSectors = freeClusters * fatFs->csize;
    int totalSectors = (fatFs->n_fatent - 2) * fatFs->csize;
    mLcd->debug (LCD_COLOR_WHITE, "%d free of %d total", freeSectors/2, totalSectors/2);
    }
  }
//}}}

//{{{
int cApp::loadFile (uint8_t* jpegBuffer) {

  auto fatFs = (FATFS*)malloc (sizeof (FATFS));
  if (!f_mount (fatFs, "", 0)) {
    f_getlabel ("", mLabel, &mVsn);
    mLcd->debug (LCD_COLOR_WHITE, "Label <%s> ", mLabel);

    //char pathName[256] = "/";
    //readDirectory (pathName);
    FILINFO filInfo;
    if (!f_stat ("image.jpg", &filInfo))
      mLcd->debug (LCD_COLOR_WHITE, "%d %u/%02u/%02u %02u:%02u %c%c%c%c%c",
                   (int)(filInfo.fsize),
                   (filInfo.fdate >> 9) + 1980, filInfo.fdate >> 5 & 15, filInfo.fdate & 31,
                    filInfo.ftime >> 11, filInfo.ftime >> 5 & 63,
                   (filInfo.fattrib & AM_DIR) ? 'D' : '-',
                   (filInfo.fattrib & AM_RDO) ? 'R' : '-',
                   (filInfo.fattrib & AM_HID) ? 'H' : '-',
                   (filInfo.fattrib & AM_SYS) ? 'S' : '-',
                   (filInfo.fattrib & AM_ARC) ? 'A' : '-');

    FIL file;
    if (!f_open (&file, "image.jpg", FA_READ)) {
      mLcd->debug (LCD_COLOR_WHITE, "image.jpg - found");
      UINT bytesRead;
      f_read (&file, (void*)jpegBuffer, (UINT)filInfo.fsize, &bytesRead);
      mLcd->debug (LCD_COLOR_WHITE, "image.jpg bytes read %d", bytesRead);
      f_close (&file);
      if (bytesRead > 0)
        jpegDecode (kJpegBuffer, bytesRead, kRgb565Buffer, 4);
      return bytesRead;
      }
    else
      mLcd->debug (LCD_COLOR_RED, "image.jpg - not found");
    }
  else
    mLcd->debug (LCD_COLOR_RED, "not mounted");

  return 0;
  }
//}}}
//{{{
void cApp::saveFile (uint8_t* jpegHeadBuf, int jpegHeadLen, uint8_t* jpegBuf, int jpegLen, int num) {

  char saveName[40];
  sprintf (saveName, "saveImage%03d.jpg", num);
  mLcd->debug (LCD_COLOR_GREEN, saveName);

  FIL file;
  if (!f_open (&file, saveName, FA_WRITE | FA_CREATE_ALWAYS)) {
    UINT bytesWritten;
    if (jpegHeadBuf && jpegHeadLen)
      f_write (&file, jpegHeadBuf, jpegHeadLen, &bytesWritten);
    f_write (&file, jpegBuf, jpegLen, &bytesWritten);
    f_close (&file);
    }
  else
    mLcd->debug (LCD_COLOR_RED, saveName);
  }
//}}}
//{{{
void cApp::jpegDecode (uint8_t* jpegBuf, int jpegLen, uint16_t* rgb565buf, int scale) {

  jpeg_mem_src (&mCinfo, jpegBuf, jpegLen);
  jpeg_read_header (&mCinfo, TRUE);

  mLcd->debug (LCD_COLOR_WHITE, "jpegDecode in:%dx%d", mCinfo.image_width, mCinfo.image_height);

  mCinfo.dct_method = JDCT_FLOAT;
  mCinfo.out_color_space = JCS_RGB;
  mCinfo.scale_num = 1;
  mCinfo.scale_denom = scale;

  jpeg_start_decompress (&mCinfo);
  while (mCinfo.output_scanline < mCinfo.output_height) {
    jpeg_read_scanlines (&mCinfo, mBufferArray, 1);
    mLcd->convertRgb888toRgbB565 (mBufferArray[0], rgb565buf + (mCinfo.output_scanline * mCinfo.output_width), mCinfo.output_width);
    }
  jpeg_finish_decompress (&mCinfo);

  mLcd->debug (LCD_COLOR_WHITE, "jpegDecode out:%dx%d %d", mCinfo.output_width, mCinfo.output_height, scale);
  }
//}}}

//{{{
const uint8_t kJpegStdQuantTblY_ZZ[64] = {
   16,  11,  12,  14,  12,  10,  16,  14,
   13,  14,  18,  17,  16,  19,  24,  40,
   26,  24,  22,  22,  24,  49,  35,  37,
   29,  40,  58,  51,  61,  60,  57,  51,
   56,  55,  64,  72,  92,  78,  64,  68,
   87,  69,  55,  56,  80, 109,  81,  87,
   95,  98, 103, 104, 103,  62,  77, 113,
  121, 112, 100, 120,  92, 101, 103,  99 };
//}}}
//{{{
const uint8_t kJpegStdQuantTblC_ZZ[64] = {
  17, 18, 18, 24, 21, 24, 47, 26,
  26, 47, 99, 66, 56, 66, 99, 99,
  99, 99, 99, 99, 99, 99, 99, 99,
  99, 99, 99, 99, 99, 99, 99, 99,
  99, 99, 99, 99, 99, 99, 99, 99,
  99, 99, 99, 99, 99, 99, 99, 99,
  99, 99, 99, 99, 99, 99, 99, 99,
  99, 99, 99, 99, 99, 99, 99, 99 };
//}}}
//{{{
const uint16_t kJpegStdHuffmanTbl[384] = {
  0x100, 0x101, 0x204, 0x30b, 0x41a, 0x678, 0x7f8, 0x9f6,
  0xf82, 0xf83, 0x30c, 0x41b, 0x679, 0x8f6, 0xaf6, 0xf84,
  0xf85, 0xf86, 0xf87, 0xf88, 0x41c, 0x7f9, 0x9f7, 0xbf4,
  0xf89, 0xf8a, 0xf8b, 0xf8c, 0xf8d, 0xf8e, 0x53a, 0x8f7,
  0xbf5, 0xf8f, 0xf90, 0xf91, 0xf92, 0xf93, 0xf94, 0xf95,
  0x53b, 0x9f8, 0xf96, 0xf97, 0xf98, 0xf99, 0xf9a, 0xf9b,
  0xf9c, 0xf9d, 0x67a, 0xaf7, 0xf9e, 0xf9f, 0xfa0, 0xfa1,
  0xfa2, 0xfa3, 0xfa4, 0xfa5, 0x67b, 0xbf6, 0xfa6, 0xfa7,
  0xfa8, 0xfa9, 0xfaa, 0xfab, 0xfac, 0xfad, 0x7fa, 0xbf7,
  0xfae, 0xfaf, 0xfb0, 0xfb1, 0xfb2, 0xfb3, 0xfb4, 0xfb5,
  0x8f8, 0xec0, 0xfb6, 0xfb7, 0xfb8, 0xfb9, 0xfba, 0xfbb,
  0xfbc, 0xfbd, 0x8f9, 0xfbe, 0xfbf, 0xfc0, 0xfc1, 0xfc2,
  0xfc3, 0xfc4, 0xfc5, 0xfc6, 0x8fa, 0xfc7, 0xfc8, 0xfc9,
  0xfca, 0xfcb, 0xfcc, 0xfcd, 0xfce, 0xfcf, 0x9f9, 0xfd0,
  0xfd1, 0xfd2, 0xfd3, 0xfd4, 0xfd5, 0xfd6, 0xfd7, 0xfd8,
  0x9fa, 0xfd9, 0xfda, 0xfdb, 0xfdc, 0xfdd, 0xfde, 0xfdf,
  0xfe0, 0xfe1, 0xaf8, 0xfe2, 0xfe3, 0xfe4, 0xfe5, 0xfe6,
  0xfe7, 0xfe8, 0xfe9, 0xfea, 0xfeb, 0xfec, 0xfed, 0xfee,
  0xfef, 0xff0, 0xff1, 0xff2, 0xff3, 0xff4, 0xff5, 0xff6,
  0xff7, 0xff8, 0xff9, 0xffa, 0xffb, 0xffc, 0xffd, 0xffe,
  0x30a, 0xaf9, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff,
  0xfd0, 0xfd1, 0xfd2, 0xfd3, 0xfd4, 0xfd5, 0xfd6, 0xfd7,
  0x101, 0x204, 0x30a, 0x418, 0x419, 0x538, 0x678, 0x8f4,
  0x9f6, 0xbf4, 0x30b, 0x539, 0x7f6, 0x8f5, 0xaf6, 0xbf5,
  0xf88, 0xf89, 0xf8a, 0xf8b, 0x41a, 0x7f7, 0x9f7, 0xbf6,
  0xec2, 0xf8c, 0xf8d, 0xf8e, 0xf8f, 0xf90, 0x41b, 0x7f8,
  0x9f8, 0xbf7, 0xf91, 0xf92, 0xf93, 0xf94, 0xf95, 0xf96,
  0x53a, 0x8f6, 0xf97, 0xf98, 0xf99, 0xf9a, 0xf9b, 0xf9c,
  0xf9d, 0xf9e, 0x53b, 0x9f9, 0xf9f, 0xfa0, 0xfa1, 0xfa2,
  0xfa3, 0xfa4, 0xfa5, 0xfa6, 0x679, 0xaf7, 0xfa7, 0xfa8,
  0xfa9, 0xfaa, 0xfab, 0xfac, 0xfad, 0xfae, 0x67a, 0xaf8,
  0xfaf, 0xfb0, 0xfb1, 0xfb2, 0xfb3, 0xfb4, 0xfb5, 0xfb6,
  0x7f9, 0xfb7, 0xfb8, 0xfb9, 0xfba, 0xfbb, 0xfbc, 0xfbd,
  0xfbe, 0xfbf, 0x8f7, 0xfc0, 0xfc1, 0xfc2, 0xfc3, 0xfc4,
  0xfc5, 0xfc6, 0xfc7, 0xfc8, 0x8f8, 0xfc9, 0xfca, 0xfcb,
  0xfcc, 0xfcd, 0xfce, 0xfcf, 0xfd0, 0xfd1, 0x8f9, 0xfd2,
  0xfd3, 0xfd4, 0xfd5, 0xfd6, 0xfd7, 0xfd8, 0xfd9, 0xfda,
  0x8fa, 0xfdb, 0xfdc, 0xfdd, 0xfde, 0xfdf, 0xfe0, 0xfe1,
  0xfe2, 0xfe3, 0xaf9, 0xfe4, 0xfe5, 0xfe6, 0xfe7, 0xfe8,
  0xfe9, 0xfea, 0xfeb, 0xfec, 0xde0, 0xfed, 0xfee, 0xfef,
  0xff0, 0xff1, 0xff2, 0xff3, 0xff4, 0xff5, 0xec3, 0xff6,
  0xff7, 0xff8, 0xff9, 0xffa, 0xffb, 0xffc, 0xffd, 0xffe,
  0x100, 0x9fa, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff,
  0xfd0, 0xfd1, 0xfd2, 0xfd3, 0xfd4, 0xfd5, 0xfd6, 0xfd7,
  0x100, 0x202, 0x203, 0x204, 0x205, 0x206, 0x30e, 0x41e,
  0x53e, 0x67e, 0x7fe, 0x8fe, 0xfff, 0xfff, 0xfff, 0xfff,
  0x100, 0x101, 0x102, 0x206, 0x30e, 0x41e, 0x53e, 0x67e,
  0x7fe, 0x8fe, 0x9fe, 0xafe, 0xfff, 0xfff, 0xfff, 0xfff };
//}}}
//{{{
int cApp::jfifApp0Marker (uint8_t* ptr) {

  *ptr++ = 0xFF; // APP0 marker
  *ptr++ = 0xE0;

  int length = 16;
  *ptr++ = length >> 8;// length field
  *ptr++ = length & 0xFF;

  *ptr++ = 0x4A; // JFIF identifier
  *ptr++ = 0x46;
  *ptr++ = 0x49;
  *ptr++ = 0x46;
  *ptr++ = 0x00;

  *ptr++ = 0x01; // version
  *ptr++ = 0x02;

  *ptr++ = 0x00; // units
  *ptr++ = 0x00; // X density
  *ptr++ = 0x01;
  *ptr++ = 0x00; // Y density
  *ptr++ = 0x01;

  *ptr++ = 0x00; // X thumbnail
  *ptr++ = 0x00; // Y thumbnail

  return length+2;
  }
//}}}
//{{{
int cApp::sofMarker (uint8_t* ptr, int width, int height) {

  *ptr++ = 0xFF; // startOfFrame: baseline DCT
  *ptr++ = 0xC0;

  int length = 17;
  *ptr++ = length >> 8;// length field
  *ptr++ = length & 0xFF;

  *ptr++ = 0x08; // sample precision

  *ptr++ = height >> 8; // number of lines
  *ptr++ = height & 0xFF;

  *ptr++ = width >> 8; // number of samples per line
  *ptr++ = width & 0xFF;

  *ptr++ = 0x03; // number of image components in frame

  *ptr++ = 0x00; // component identifier: Y
  *ptr++ = 0x21; // horizontal | vertical sampling factor: Y
  *ptr++ = 0x00; // quantization table selector: Y

  *ptr++ = 0x01; // component identifier: Cb
  *ptr++ = 0x11; // horizontal | vertical sampling factor: Cb
  *ptr++ = 0x01; // quantization table selector: Cb

  *ptr++ = 0x02; // component identifier: Cr
  *ptr++ = 0x11; // horizontal | vertical sampling factor: Cr
  *ptr++ = 0x01; // quantization table selector: Cr

  return length+2;
  }
//}}}
//{{{
int cApp::quantTableMarker (uint8_t* ptr, int qscale) {

  *ptr++ = 0xFF;// quantization table marker
  *ptr++ = 0xDB;

  int length = 132;
  *ptr++ = length >> 8;// length field
  *ptr++ = length & 0xFF;

  *ptr++ = 0;// quantization table precision | identifier
  for (int i = 0; i < 64; i++) {
    int q = (kJpegStdQuantTblY_ZZ[i] * qscale + 16) >> 5;
    *ptr++ = q;// quantization table element
    }

  *ptr++ = 1;// quantization table precision | identifier
  for (int i = 0; i < 64; i++) {
    int q = (kJpegStdQuantTblC_ZZ[i] * qscale + 16) >> 5;
    *ptr++ = q;// quantization table element
    }

  return length+2;
  }
//}}}
//{{{
int cApp::huffTableMarkerAC (uint8_t* ptr, const uint16_t* htable, int classId) {

  *ptr++ = 0xFF; // huffman table marker
  *ptr++ = 0xC4;

  int length = 19;
  uint8_t* plength = ptr; // place holder for length field
  *ptr++;
  *ptr++;

  *ptr++ = classId;// huffman table class identifier
  for (int l = 0; l < 16; l++) {
    int count = 0;
    for (int i = 0; i < 162; i++) {
      if ((htable[i] >> 8) == l)
        count++;
      }
    *ptr++ = count; // number of huffman codes of length l+1
    }

  for (int l = 0; l < 16; l++) {
    // check EOB: 0|0
    if ((htable[160] >> 8) == l) {
      *ptr++ = 0; // HUFFVAL with huffman codes of length l+1
      length++;
      }

    // check HUFFVAL: 0|1 to E|A
    for (int i = 0; i < 150; i++) {
      if ((htable[i] >> 8) == l) {
        int a = i/10;
        int b = i%10;
        *ptr++ = (a<<4)|(b+1); // HUFFVAL with huffman codes of length l+1
        length++;
        }
      }

    // check ZRL: F|0
    if ((htable[161] >> 8) == l) {
      *ptr++ = 0xF0; // HUFFVAL with huffman codes of length l+1
      length++;
      }

    // check HUFFVAL: F|1 to F|A
    for (int i = 150; i < 160; i++) {
      if ((htable[i] >> 8) == l) {
        int a = i/10;
        int b = i%10;
        *ptr++ = (a<<4)|(b+1); // HUFFVAL with huffman codes of length l+1
        length++;
        }
      }
    }

  *plength++ = length >> 8; // length field
  *plength = length & 0xFF;

  return length + 2;
  }
//}}}
//{{{
int cApp::huffTableMarkerDC (uint8_t* ptr, const uint16_t* htable, int classId) {

  *ptr++ = 0xFF; // huffman table marker
  *ptr++ = 0xC4;

  int length = 19;
  uint8_t* plength = ptr; // place holder for length field
  *ptr++;
  *ptr++;

  *ptr++ = classId; // huffman table class identifier
  for (int l = 0; l < 16; l++) {
    int count = 0;
    for (int i = 0; i < 12; i++) {
      if ((htable[i] >> 8) == l)
        count++;
      }
    *ptr++ = count; // number of huffman codes of length l+1
    }

  for (int l = 0; l < 16; l++) {
    for (int i = 0; i < 12; i++) {
      if ((htable[i] >> 8) == l) {
        *ptr++ = i; // HUFFVAL with huffman codes of length l+1
        length++;
        }
      }
    }

  *plength++ = length >> 8;// length field
  *plength = length & 0xFF;

  return length + 2;
  }
//}}}
//{{{
int cApp::sosMarker (uint8_t* ptr) {

  *ptr++ = 0xFF;// startOfScan marker
  *ptr++ = 0xDA;

  int length = 12;
  *ptr++ = length >> 8;// length field
  *ptr++ = length & 0xFF;

  *ptr++ = 0x03;// number of image components in scan
  *ptr++ = 0x00;// scan component selector: Y
  *ptr++ = 0x00;// DC | AC huffman table selector: Y
  *ptr++ = 0x01;// scan component selector: Cb
  *ptr++ = 0x11;// DC | AC huffman table selector: Cb
  *ptr++ = 0x02;// scan component selector: Cr
  *ptr++ = 0x11;// DC | AC huffman table selector: Cr

  *ptr++ = 0x00;// Ss: start of predictor selector
  *ptr++ = 0x3F;// Se: end of spectral selector
  *ptr++ = 0x00;// Ah | Al: successive approximation bit position

  return length+2;
  }
//}}}
//{{{
void cApp::setJpegHeader (int width, int height, int qscale) {

  auto ptr = mJpegHeader;

  *ptr++ = 0xFF; // SOI marker
  *ptr++ = 0xD8;
  mJpegHeaderLen = 2;

  mJpegHeaderLen += jfifApp0Marker (ptr);
  mJpegHeaderLen += quantTableMarker (mJpegHeader + mJpegHeaderLen, qscale);
  mJpegHeaderLen += sofMarker (mJpegHeader + mJpegHeaderLen, width, height);
  mJpegHeaderLen += huffTableMarkerAC (mJpegHeader + mJpegHeaderLen, &kJpegStdHuffmanTbl[0], 0x10);
  mJpegHeaderLen += huffTableMarkerAC (mJpegHeader + mJpegHeaderLen, &kJpegStdHuffmanTbl[176], 0x11);
  mJpegHeaderLen += huffTableMarkerDC (mJpegHeader + mJpegHeaderLen, &kJpegStdHuffmanTbl[352], 0x00);
  mJpegHeaderLen += huffTableMarkerDC (mJpegHeader + mJpegHeaderLen, &kJpegStdHuffmanTbl[368], 0x01);
  mJpegHeaderLen += sosMarker (mJpegHeader + mJpegHeaderLen);
  }
//}}}

//{{{
void MPU_Config() {

  // Disable the MPU
  HAL_MPU_Disable();

  // Configure the MPU attributes as WT for SRAM
  MPU_Region_InitTypeDef MPU_InitStruct;
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.BaseAddress = 0x20010000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion (&MPU_InitStruct);

  // Configure the MPU as Normal Non Cacheable for Ethernet Buffers in the SRAM2
  MPU_InitStruct.Number = MPU_REGION_NUMBER1;
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.BaseAddress = 0x2004C000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_16KB;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL1;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion (&MPU_InitStruct);

  // Configure the MPU as Device for Ethernet Descriptors in the SRAM2
  MPU_InitStruct.Number = MPU_REGION_NUMBER2;
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.BaseAddress = 0x2004C000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_256B;
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable = 0x00;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion (&MPU_InitStruct);

  // Enable the MPU
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
  }
//}}}
//{{{
void startThread (void* argument) {

  // Initialize app
  gApp = new cApp (cLcd::getWidth(), cLcd::getHeight());
  gApp->init();

  // init network
  tcpip_init (NULL, NULL);

  // network config
  ip_addr_t ipaddr;
  ip_addr_set_zero_ip4 (&ipaddr);
  ip_addr_t netmask;
  ip_addr_set_zero_ip4 (&netmask);
  ip_addr_t gw;
  ip_addr_set_zero_ip4 (&gw);

  // static
  //  IP_ADDR4 (&ipaddr,192,168,0,10);
  //  IP_ADDR4 (&netmask,255,255,255,0);
  //  IP_ADDR4 (&gw,192,168,GW_ADDR2,1);
  netif_add (&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
  netif_set_default (&gnetif);
  if (netif_is_link_up (&gnetif))
    netif_set_up (&gnetif);
  else
    netif_set_down (&gnetif);

  // init httpServer
  sys_thread_new ("Http", httpServerThread, NULL, DEFAULT_THREAD_STACKSIZE, osPriorityAboveNormal);

  // init dhcp
  sys_thread_new ("Dhcp", dhcpThread, &gnetif, configMINIMAL_STACK_SIZE * 2, osPriorityBelowNormal);

  gApp->run();
  //while (true)
  //  osThreadTerminate(NULL);
  }
//}}}
//{{{
int main() {

  MPU_Config();
  SCB_EnableICache();
  SCB_EnableDCache();
  HAL_Init();
  //{{{  config system clock
  // System Clock source            = PLL (HSE)
  // SYSCLK(Hz)                     = 216000000
  // HCLK(Hz)                       = 216000000
  // AHB Prescaler                  = 1
  // APB1 Prescaler                 = 4
  // APB2 Prescaler                 = 2
  // HSE Frequency(Hz)              = 25000000
  // PLL_M                          = 25
  // PLL_N                          = 432
  // PLL_P                          = 2
  // PLLSAI_N                       = 384
  // PLLSAI_P                       = 8
  // VDD(V)                         = 3.3
  // Main regulator output voltage  = Scale1 mode
  // Flash Latency(WS)              = 7

  // Enable HSE Oscillator and activate PLL with HSE as source
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 432;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 9;
  if (HAL_RCC_OscConfig (&RCC_OscInitStruct) != HAL_OK)
    while (true) {}

  // Activate the OverDrive to reach the 216 Mhz Frequency
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
    while (true) {}

  // Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
                                 RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  if (HAL_RCC_ClockConfig (&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
    while (true) {}
  //}}}
  BSP_PB_Init (BUTTON_KEY, BUTTON_MODE_GPIO);

  sys_thread_new ("Start", startThread, NULL, configMINIMAL_STACK_SIZE * 5, osPriorityNormal);
  osKernelStart();

  while (true);
  }
//}}}
